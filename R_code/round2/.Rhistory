}
# 偶数数手（第2手逆）根据第一手的against或follow:
else if(i %in% seq(18,n,4)){
temptMatrix_final_result=sapply(rbind(pre[seq(i-2,i-9,-1),],data.frame(matrix(rep(data[i,m],8),ncol=8),row.names = i))
,function(x){new_quantize(path,set=x,Inverse = T,R)})
# 不同的plan
if(choice==12113|choice==12115|choice==12117){
# 根据第1手结果against
for(j in 1:8){
# 计算每个final result:根据第一手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-1,j]>0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12114|choice==12116|choice==12118){
# follow
for(j in 1:8){
# 计算每个final result:根据第一手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-1,j]<0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
}
# 奇数手（第3手顺）固定相反formula或根据 第一手 的against或follow:
else if(i %in% seq(19,n,4)){
temptMatrix_final_result=sapply(rbind(pre[seq(i-8,i-1,1),],data.frame(matrix(rep(data[i,m],8),ncol=8),row.names = i))
,function(x){new_quantize(path,set=x,Inverse = F,R)})
if(choice==12113|choice==12114){
for(j in 1:8){
# 计算每个final result:使用相反formula,次对角元素
final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
}
}
else if(choice==12115|choice==12116){
# against第一手
for(j in 1:8){
# 计算每个final result:根据第一手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-2,j]>0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12117|choice==12118){
# follow 第一手
for(j in 1:8){
# 计算每个final result:根据第一手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-2,j]<0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
}
# 偶数手（第4手逆）第1、3手的结果against或follow
else{
# 先计算8个formula下对应8条路径的的结果结果矩阵，1列表示1条路径下8个formula的结果
temptMatrix_final_result=sapply(rbind(pre[seq(i-2,i-9,-1),],data.frame(matrix(rep(data[i,m],8),ncol=8),row.names = i))
,function(x){new_quantize(path,set=x,Inverse = T,R)})
# 不同的plan
if(choice==12113){
# 简单against第三手
for(j in 1:8){
# 计算每个final result:根据第三手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-1,j]>0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12114){
# 简单follow第三手
for(j in 1:8){
# 计算每个final result:根据第一手的final result against,正时使用相反formula，负的时候使用相同formula
if(final_result[i-1,j]<0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12115){
# against 根据1、3手结果，3手against第1手
for(j in 1:8){
if(final_result[i-1,j]*final_result[i-3,j]<0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12116){
# follow 根据1、3手结果，3手against第1手
for(j in 1:8){
if(final_result[i-1,j]*final_result[i-3,j]>0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12117){
# against 根据1、3手结果，3手follow第1手
for(j in 1:8){
if(final_result[i-1,j]*final_result[i-3,j]>0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
else if(choice==12118){
# follow 根据1、3手结果，3手follow第1手
for(j in 1:8){
if(final_result[i-1,j]*final_result[i-3,j]<0)final_result[i,j]=temptMatrix_final_result[abs(j-9),j]
else final_result[i,j]=temptMatrix_final_result[j,j]
}
}
}
# 2、计算预测值,只与final result和真实数据有关
pre[i,]=ifelse(final_result[i,]>0,ifelse(data[i,m]=='B','B','P'),ifelse(data[i,m]=='B','P','B'))
}
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
pre=pre[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:nrow(path)))
colnames(pre)=c(paste0('trace',1:nrow(path)))
return(list(final_result,pre))
}
# 单轨，原始数据，2个一组
data_sort_1226_origin_one=function(data,m,choice,connect){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 奇数手：逆
for (i in seq(9,n,2)) {
# 计算final result
final_result[i,]=new_quantize579(set = data[c(seq(i-1,i-8,-1),i),m],order =F ,connect = connect)
}
# 偶数手：顺
for (i in seq(10,n,2)) {
final_tempt=new_quantize579(set = data[c(seq(i-8,i-1,1),i),m],order =T ,connect = connect)
if(choice==122610){final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==122620){final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==122690){final_result[i,]=-final_tempt}
}
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
data_sort_107_origin_one=function(data,m,choice,connect){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 奇数手：逆
for (i in seq(9,n,2)) {
# 计算final result
final_result[i,]=new_quantize579(set = data[c(seq(i-1,i-8,-1),i),m],order =F ,connect = connect)
}
# 偶数手：顺
for (i in seq(10,n,2)) {
final_tempt=new_quantize579(set = data[c(seq(i-9,i-2,1),i),m],order =T ,connect = connect)
if(choice==10710){final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==10720){final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==10790){final_result[i,]=-final_tempt}
}
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
data_sort_1227_origin_one=function(data,m,choice,connect){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 奇数手：逆,path_BP_YAY579
for (i in seq(9,n,2)) {
# 计算final result
final_result[i,]=new_quantize579(set = data[c(seq(i-1,i-8,-1),i),m],order =F ,connect = connect)
}
# 偶数手：顺,path_BP_YAY668810，且是10手
for (i in seq(10,n,2)) {
final_tempt=new_quantize668810(set = data[c(seq(i-9,i-1,1),i),m],order =T ,connect = connect)
if(choice==122710){final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==122720){final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==122790){final_result[i,]=-final_tempt}
}
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
data_sort_1213_origin_one=function(data,m,choice,connect){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 奇数手：顺,path_BP_YAY579
for (i in seq(9,n,2)) {
# 计算final result
final_result[i,]=new_quantize579(set = data[c(seq(i-8,i-1,1),i),m],order = T,connect = connect)
}
# 偶数手：逆,path_BP_YAY668810，且是10手
for (i in seq(10,n,2)) {
final_tempt=new_quantize668810(set = data[c(seq(i-1,i-9,-1),i),m],order = F,connect = connect)
if(choice==121310){final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==121320){final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==121390){final_result[i,]=-final_tempt}
}
# 2、合再一起做，因为互相用到数据
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
data_sort_106_origin_one=function(data,m,choice,connect){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 奇数手：逆,path_BP_YAY579
for (i in seq(9,n,2)) {
# 计算final result
final_result[i,]=new_quantize579(set = data[c(seq(i-1,i-8,-1),i),m],order =F ,connect = connect)
}
# 偶数手：顺,path_BP_YAY668810，且是10手
for (i in seq(10,n,2)) {
final_tempt=new_quantize668810(set = data[c(i-1,seq(i-9,i-2,1),i),m],order =T ,connect = connect,separate=T)
if(choice==10610){final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==10620){final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==10690){final_result[i,]=-final_tempt}
}
# 3、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
# 单轨，原始数据，4个一组
data_sort_sequence_inverse_origin_two=function(data,m,choice,path=path,R){
n=nrow(data)
final_result=matrix(nrow = n,ncol = 8) # final_result
row.names(final_result)=1:n
# 1、先计算使用原始数据的9-16手
# 第一手数据，奇数手：顺,使用original formula
for (i in seq(9,n,4)) {
# 计算final result
final_result[i,]=new_quantize(path,set = data[c(seq(i-8,i-1,1),i),m],Inverse = F,R)
}
# 第二手，偶数手：逆，根据第一手follow或者against
for (i in seq(10,n,4)) {
final_tempt=new_quantize(path,set = data[c(seq(i-2,i-9,-1),i),m],Inverse = T,R)
if(choice==121130|choice==121150|choice==121170){
# against
final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==121140|choice==121160|choice==121180){
# follow
final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
}
# 第三手数据，奇数手：顺,使用 固定相反 formula、follow第一手或者against第一手
for (i in seq(11,n,4)) {
# 计算final result
final_tempt=new_quantize(path,set = data[c(seq(i-8,i-1,1),i),m],Inverse = F,R)
if(choice==121130|choice==121140){
# 固定的相反
final_result[i,]=-final_tempt
}
else if(choice==121150|choice==121160){
# against第一手
final_result[i,]=ifelse(final_result[i-2,]>0,-final_tempt,final_tempt)
}
else if(choice==121170|choice==121180){
# follow 第一手
final_result[i,]=ifelse(final_result[i-2,]>0,final_tempt,-final_tempt)
}
}
# 第四手，偶数手：逆，根据第三手follow或者against，注意在第三手非固定使用formula时，也受到第一手影响
for (i in seq(12,n,4)) {
final_tempt=new_quantize(path,set = data[c(seq(i-2,i-9,-1),i),m],Inverse = T,R)
if(choice==121130){
# against
final_result[i,]=ifelse(final_result[i-1,]>0,-final_tempt,final_tempt)}
else if(choice==121140){
# follow
final_result[i,]=ifelse(final_result[i-1,]>0,final_tempt,-final_tempt)}
else if(choice==121150){
# against 根据1、3手结果，3手against第1手
final_result[i,]=ifelse(final_result[i-1,]*final_result[i-3,]>0,final_tempt,-final_tempt)}
else if(choice==121160){
# follow 根据1、3手结果，3手against第1手
final_result[i,]=ifelse(final_result[i-1,]*final_result[i-3,]<0,final_tempt,-final_tempt)}
else if(choice==121170){
# against 根据1、3手结果，3手follow第1手
final_result[i,]=ifelse(final_result[i-1,]*final_result[i-3,]<0,final_tempt,-final_tempt)}
else if(choice==121180){
# follow 根据1、3手结果，3手follow第1手
final_result[i,]=ifelse(final_result[i-1,]*final_result[i-3,]>0,final_tempt,-final_tempt)}
}
# 2、去除无法计算final result的：
final_result=final_result[-c(1:8),]
colnames(final_result)=c(paste0('trace',1:8))
return(list(final_result))
}
}
run=function(data=data,choice,connect){
library(stringr)
n_path=8
minus_result=matrix(nrow =length(data),ncol = n_path)
plus=matrix(nrow =length(data),ncol = n_path)
minus=matrix(nrow =length(data),ncol = n_path)
new_indexE1=matrix(nrow =length(data),ncol = n_path)
new_indexE2=matrix(nrow =length(data),ncol = n_path)
for (m in 1:length(data)) {
if(m%%50==0)print(m)
if(choice %in% c(12271,12272,12279)){
temp=data_sort_1227_one(data,m,choice,connect = connect)
}
else if(choice %in% c(122710,122720,122790)){
temp=data_sort_1227_origin_one(data,m,choice,connect = connect)
}
else if(choice %in% c(12131,12132,12139)){
temp=data_sort_1213_one(data,m,choice,connect = connect)
}
else if(choice %in% c(121310,121320,121390)){
temp=data_sort_1213_origin_one(data,m,choice,connect = connect)
}
else if(choice %in% c(12261,12262,12269)){
temp=data_sort_1226_one(data,m,choice,connect = connect)
}
else if(choice %in% c(122610,122620,122690)){
temp=data_sort_1226_origin_one(data,m,choice,connect = connect)
}
else if(choice %in% c(1061,1062,1069)){
temp=data_sort_106_one(data,m,choice,connect = connect)
}
else if(choice %in% c(10610,10620,10690)){
temp=data_sort_106_origin_one(data,m,choice,connect = connect)
}
else if(choice %in% c(1071,1072,1079)){
temp=data_sort_107_one(data,m,choice,connect = connect)
}
else if(choice %in% c(10710,10720,10790)){
temp=data_sort_107_origin_one(data,m,choice,connect = connect)
}
# 1）初始化变量，以记录指标：
{
sumtemp=temp[[1]]
n_sumtemp=nrow(sumtemp)
}
# 2）每个数据集m计算多个评价指标：
{
# 计算连续负 “最大” 的手数
minus_result[m,]=detect_continue_minus(sumtemp)
# 计算新指标:评价指标
# 1、正负比例
plus[m,]=apply(sumtemp, 2, function(x)sum(x>0))
minus[m,]=n_sumtemp-plus[m,]# 数据m下结果负的手数
symbol=ifelse(sumtemp>0,1,-1)
patternE1=matrix(rep(c(rep(c(1,2),(n_sumtemp)%/%2),c(1,2)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE1[m,]=colSums(patternE1*symbol)
patternE2=matrix(rep(c(rep(c(2,1),(n_sumtemp)%/%2),c(2,1)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE2[m,]=colSums(patternE2*symbol)
}
}
colnames(minus_result)=c(paste0('formula',1:n_path))
# result存放最大连续负个数
result=matrix(nrow =max(minus_result) ,ncol = n_path)
for (i in 1:(max(minus_result))){
result[i,]=apply(minus_result,2,function(x)sum(x==i))
}
colnames(result)=c(paste0('formula',1:n_path))
# satisfy为某一个formula满足小于等于5的数据集个数：
satisfy=apply(result[1:5,], 2, sum)
return(list(minus_result,result,satisfy,plus,minus,
new_indexE1,new_indexE2))
}
run7911=function(data=data,path=path,choice){
library(stringr)
n_path=nrow(path)
minus_result=matrix(nrow =length(data),ncol = n_path)
plus=matrix(nrow =length(data),ncol = n_path)
minus=matrix(nrow =length(data),ncol = n_path)
new_indexE1=matrix(nrow =length(data),ncol = n_path)
new_indexE2=matrix(nrow =length(data),ncol = n_path)
for (m in 1:length(data)) {
if(m%%50==0)print(m)
if(choice %in% c(12111,12112,12119)){
temp=data_sort_sequence_inverse_one7911(data,m,choice,path)
}
else if(choice %in% c(121110,121120,121190)){
temp=data_sort_sequence_inverse_origin_one7911(data,m,choice,path)
}
else if(choice %in% c(12113,12114,12115,12116,12117,12118)){
temp=data_sort_sequence_inverse_two(data,m,choice,path,R)
}
else if(choice %in% c(121130,121140,121150,121160,121170,121180)){
temp=data_sort_sequence_inverse_origin_two(data,m,choice,path,R)
}
# 1）初始化变量，以记录指标：
{
sumtemp=temp[[1]]
n_sumtemp=nrow(sumtemp)
}
# 2）每个数据集m计算多个评价指标：
{
# 计算连续负 “最大” 的手数
minus_result[m,]=detect_continue_minus(sumtemp)
# 计算新指标:评价指标
# 1、正负比例
plus[m,]=apply(sumtemp, 2, function(x)sum(x>0))
minus[m,]=n_sumtemp-plus[m,]# 数据m下结果负的手数
symbol=ifelse(sumtemp>0,1,-1)
patternE1=matrix(rep(c(rep(c(1,2),(n_sumtemp)%/%2),c(1,2)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE1[m,]=colSums(patternE1*symbol)
patternE2=matrix(rep(c(rep(c(2,1),(n_sumtemp)%/%2),c(2,1)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE2[m,]=colSums(patternE2*symbol)
}
}
colnames(minus_result)=c(paste0('formula',1:n_path))
# result存放最大连续负个数
result=matrix(nrow =max(minus_result) ,ncol = n_path)
for (i in 1:(max(minus_result))){
result[i,]=apply(minus_result,2,function(x)sum(x==i))
}
colnames(result)=c(paste0('formula',1:n_path))
# satisfy为某一个formula满足小于等于5的数据集个数：
satisfy=apply(result[1:5,], 2, sum)
return(list(minus_result,result,satisfy,plus,minus,
new_indexE1,new_indexE2))
}
run91113=function(data=data,path=path,choice){
library(stringr)
n_path=nrow(path)
minus_result=matrix(nrow =length(data),ncol = n_path)
plus=matrix(nrow =length(data),ncol = n_path)
minus=matrix(nrow =length(data),ncol = n_path)
new_indexE1=matrix(nrow =length(data),ncol = n_path)
new_indexE2=matrix(nrow =length(data),ncol = n_path)
for (m in 1:length(data)) {
if(m%%50==0)print(m)
if(choice %in% c(12111,12112,12119)){
temp=data_sort_sequence_inverse_one91113(data,m,choice,path)
}
else if(choice %in% c(121110,121120,121190)){
temp=data_sort_sequence_inverse_origin_one91113(data,m,choice,path)
}
else if(choice %in% c(12113,12114,12115,12116,12117,12118)){
temp=data_sort_sequence_inverse_two(data,m,choice,path,R)
}
else if(choice %in% c(121130,121140,121150,121160,121170,121180)){
temp=data_sort_sequence_inverse_origin_two(data,m,choice,path,R)
}
# 1）初始化变量，以记录指标：
{
sumtemp=temp[[1]]
n_sumtemp=nrow(sumtemp)
}
# 2）每个数据集m计算多个评价指标：
{
# 计算连续负 “最大” 的手数
minus_result[m,]=detect_continue_minus(sumtemp)
# 计算新指标:评价指标
# 1、正负比例
plus[m,]=apply(sumtemp, 2, function(x)sum(x>0))
minus[m,]=n_sumtemp-plus[m,]# 数据m下结果负的手数
symbol=ifelse(sumtemp>0,1,-1)
patternE1=matrix(rep(c(rep(c(1,2),(n_sumtemp)%/%2),c(1,2)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE1[m,]=colSums(patternE1*symbol)
patternE2=matrix(rep(c(rep(c(2,1),(n_sumtemp)%/%2),c(2,1)[0:((n_sumtemp)%%2)]),8),ncol = 8)
new_indexE2[m,]=colSums(patternE2*symbol)
}
}
colnames(minus_result)=c(paste0('formula',1:n_path))
# result存放最大连续负个数
result=matrix(nrow =max(minus_result) ,ncol = n_path)
for (i in 1:(max(minus_result))){
result[i,]=apply(minus_result,2,function(x)sum(x==i))
}
colnames(result)=c(paste0('formula',1:n_path))
# satisfy为某一个formula满足小于等于5的数据集个数：
satisfy=apply(result[1:5,], 2, sum)
return(list(minus_result,result,satisfy,plus,minus,
new_indexE1,new_indexE2))
}
# 2.6 展示函数
present=function(result){
library(stringr)
print(result[[2]])
cat('\n')
final_result=matrix(round(colSums(result[[4]])/colSums(result[[5]]),3),nrow = 1)
row.names(final_result)=c('plus/minus')
colnames(final_result)=c(paste0('formula',1:8))
final_result1=rbind(result[[3]],apply(result[[6]], 2, sum))
final_result1=rbind(final_result1,apply(result[[7]], 2, sum))
final_result1=rbind(final_result1,colSums(result[[4]]))
final_result1=rbind(final_result1,colSums(result[[5]]))
row.names(final_result1)=c('quantity','E1_sum','E2_sum','plus','minus')
first5_e1=apply(result[[6]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_e1=apply(result[[6]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_e2=apply(result[[7]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_e2=apply(result[[7]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
e1=str_c(first5_e1,last5_e1,sep  = ';')
e2=str_c(first5_e2,last5_e2,sep  = ';')
ss=data.frame(E1=e1,E2=e2)
row.names(ss)=c(paste0('formula',1:8))
colnames(ss)=c('first&last5 of index E1','first&last5 of index E2')
print(ss)
cat('\n')
print(final_result)
print(final_result1)
}
plan107_1_original_connect=run(data = all_data,choice=10710,connect=T)
present(plan107_1_original_connect)
plan107_1_original_connect
present(plan107_1_original_connect)
plan107_2_original_connect=run(data = all_data,choice=10720,connect=T)
present(plan107_2_original_connect)
plan107_1_connect=run(data = all_data,choice=1071,connect=T)
present(plan107_1_connect)
plan107_2_connect=run(data = all_data,choice=1072,connect=T)
present(plan107_2_connect)
present(plan107_1_original_connect)
present(plan107_1_original_connect)
present(plan107_1_original_connect)
present(plan107_2_original_connect)
present(plan107_1_connect)
present(plan107_2_connect)

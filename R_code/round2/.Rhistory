# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
else if (choice==12113&rolling==F) {
second=-second # 第二手固定使用相反的
third=ifelse(decide_first<0,third,-third)
forth=ifelse(decide_second>0,forth,-forth) # 第4手小于0时反一反
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=ifelse(decide_first<0,1,2)
patternA[seq(4,n_sumtemp,4),]=ifelse(decide_second>0,1,2)
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=ifelse(decide_first<0,2,1)
patternB[seq(4,n_sumtemp,4),]=ifelse(decide_second>0,2,1)
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
else if (choice==12114&rolling==F) {
second=-second # 第二手固定使用相反的
third=ifelse(decide_first>0,third,-third)
forth=ifelse(decide_second<0,forth,-forth)
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=ifelse(decide_first>0,1,2)
patternA[seq(4,n_sumtemp,4),]=ifelse(decide_second<0,1,2)
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=ifelse(decide_first>0,2,1)
patternB[seq(4,n_sumtemp,4),]=ifelse(decide_second<0,2,1)
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
else if (choice==1019&rolling==F) {
second=-second
# 判断是否是负负的，是的话3&4就使用（1，8），否则（8，1）
# formula1和formula8表示两组against的formula，1为original，8为against
opposite_condition=decide_first<0&decide_second<0
third=ifelse(opposite_condition,third,-third)
forth=ifelse(opposite_condition,-forth,forth)
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
patternA[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
# 滚动时不受长度影响：
else if(choice==1019&rolling==T){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
patternA[1,]=1;patternA[2,]=2
patternB[1,]=2;patternB[2,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(3,nrow(sumtemp)-1,2)) {
opposite_condition=sumtemp[i-1,]<0&sumtemp[i-2,]<0
sumtemp[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-2,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-1,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
else if(choice==10191&rolling==F){
second=-second
# 判断是否是负负或正正的，是的3&4就使用（1，8），否则（8，1）
# formula1和formula8表示两组against的formula，1为original，8为against
opposite_condition=decide_first*decide_second>0
third=ifelse(opposite_condition,third,-third)
forth=ifelse(opposite_condition,-forth,forth)
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
patternA[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
else if(choice==10191&rolling==T){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
patternA[1,]=1;patternA[2,]=2
patternB[1,]=2;patternB[2,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(3,nrow(sumtemp)-1,2)) {
opposite_condition=sumtemp[i-1,]*sumtemp[i-2,]>0
sumtemp[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-2,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-1,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
else if(choice==10192&rolling==F){
second=-second
# 判断是否是正负或正正的，是的3&4就使用（1，8），否则（8，1）
# formula1和formula8表示两组against的formula，1为original，8为against
opposite_condition=decide_first>0|decide_second>0
third=ifelse(opposite_condition,third,-third)
forth=ifelse(opposite_condition,-forth,forth)
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
patternA[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=ifelse(opposite_condition,2,1)
patternB[seq(4,n_sumtemp,4),]=ifelse(opposite_condition,1,2)
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
else if(choice==10192&rolling==T){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
patternA[1,]=1;patternA[2,]=2
patternB[1,]=2;patternB[2,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(3,nrow(sumtemp)-1,2)) {
opposite_condition=sumtemp[i-1,]>0|sumtemp[i-2,]>0
sumtemp[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-2,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i,]=ifelse(opposite_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-1,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+1,]=ifelse(opposite_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
# 往下默认都是滚动进行反一反：
# plan121015:四手为一判定条件
else if(choice==121015){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
sumtemp[3,]=-sumtemp[3,]
patternA[1,]=1;patternA[2,]=2 # 1表示某一手数据使用original
patternA[4,]=1;patternA[3,]=2
patternB[1,]=2;patternB[2,]=1 # A与B相反
patternB[4,]=2;patternB[3,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(5,nrow(sumtemp)-1,4)) {
# follow的条件:2个负时follow：
follow_condition=apply(sumtemp[(i-4):(i-1),],2,function(x){ifelse(sum(x<0)==2,T,F)})
sumtemp[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-4,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,1,2),ifelse(patternA[i-4,]==1,2,1))
patternB[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,2,1),ifelse(patternA[i-4,]==1,1,2))
sumtemp[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-3,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,1,2),ifelse(patternA[i-3,]==1,2,1))
patternB[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,2,1),ifelse(patternA[i-3,]==1,1,2))
sumtemp[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,sumtemp[i+2,],-sumtemp[i+2,]),ifelse(patternA[i-2,]==1,-sumtemp[i+2,],sumtemp[i+2,]))
patternA[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,sumtemp[i+3,],-sumtemp[i+3,]),ifelse(patternA[i-1,]==1,-sumtemp[i+3,],sumtemp[i+3,]))
patternA[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
# plan121016
else if(choice==121016){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
sumtemp[3,]=-sumtemp[3,]
patternA[1,]=1;patternA[2,]=2 # 1表示某一手数据使用original
patternA[4,]=1;patternA[3,]=2
patternB[1,]=2;patternB[2,]=1 # A与B相反
patternB[4,]=2;patternB[3,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(5,nrow(sumtemp)-1,4)) {
# follow的条件:2个负时follow：
follow_condition=!apply(sumtemp[(i-4):(i-1),],2,function(x){ifelse(sum(x<0)==2,T,F)})
sumtemp[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-4,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,1,2),ifelse(patternA[i-4,]==1,2,1))
patternB[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,2,1),ifelse(patternA[i-4,]==1,1,2))
sumtemp[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-3,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,1,2),ifelse(patternA[i-3,]==1,2,1))
patternB[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,2,1),ifelse(patternA[i-3,]==1,1,2))
sumtemp[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,sumtemp[i+2,],-sumtemp[i+2,]),ifelse(patternA[i-2,]==1,-sumtemp[i+2,],sumtemp[i+2,]))
patternA[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,sumtemp[i+3,],-sumtemp[i+3,]),ifelse(patternA[i-1,]==1,-sumtemp[i+3,],sumtemp[i+3,]))
patternA[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
# plan121017
else if(choice==121017){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
sumtemp[4,]=-sumtemp[4,]
patternA[1,]=1;patternA[2,]=2 # 1表示某一手数据使用original
patternA[3,]=1;patternA[4,]=2
patternB[1,]=2;patternB[2,]=1 # A与B相反
patternB[3,]=2;patternB[4,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(5,nrow(sumtemp)-1,4)) {
# follow的条件:2个负时follow：
follow_condition=apply(sumtemp[(i-4):(i-1),],2,function(x){ifelse(sum(x<0)==2,T,F)})
sumtemp[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-4,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,1,2),ifelse(patternA[i-4,]==1,2,1))
patternB[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,2,1),ifelse(patternA[i-4,]==1,1,2))
sumtemp[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-3,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,1,2),ifelse(patternA[i-3,]==1,2,1))
patternB[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,2,1),ifelse(patternA[i-3,]==1,1,2))
sumtemp[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,sumtemp[i+2,],-sumtemp[i+2,]),ifelse(patternA[i-2,]==1,-sumtemp[i+2,],sumtemp[i+2,]))
patternA[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,sumtemp[i+3,],-sumtemp[i+3,]),ifelse(patternA[i-1,]==1,-sumtemp[i+3,],sumtemp[i+3,]))
patternA[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
# plan121018
else if(choice==121018){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
sumtemp[4,]=-sumtemp[4,]
patternA[1,]=1;patternA[2,]=2 # 1表示某一手数据使用original
patternA[3,]=1;patternA[4,]=2
patternB[1,]=2;patternB[2,]=1 # A与B相反
patternB[3,]=2;patternB[4,]=1
# 注意相比不滚动的，需要多1个变量用以记录前一个的路径，follow的不一定是（1，8）
# patternA 刚好记录了路径
# 2重判断，第一判定是否follow，第2判定follow哪一个
for (i in seq(5,nrow(sumtemp)-1,4)) {
# follow的条件:2个负时follow：
follow_condition=!apply(sumtemp[(i-4):(i-1),],2,function(x){ifelse(sum(x<0)==2,T,F)})
sumtemp[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-4,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,1,2),ifelse(patternA[i-4,]==1,2,1))
patternB[i,]=ifelse(follow_condition,ifelse(patternA[i-4,]==1,2,1),ifelse(patternA[i-4,]==1,1,2))
sumtemp[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-3,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,1,2),ifelse(patternA[i-3,]==1,2,1))
patternB[i+1,]=ifelse(follow_condition,ifelse(patternA[i-3,]==1,2,1),ifelse(patternA[i-3,]==1,1,2))
sumtemp[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,sumtemp[i+2,],-sumtemp[i+2,]),ifelse(patternA[i-2,]==1,-sumtemp[i+2,],sumtemp[i+2,]))
patternA[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i+2,]=ifelse(follow_condition,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,sumtemp[i+3,],-sumtemp[i+3,]),ifelse(patternA[i-1,]==1,-sumtemp[i+3,],sumtemp[i+3,]))
patternA[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+3,]=ifelse(follow_condition,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
# plan1019-20-1
else if(choice==1019201){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
# plan1019-20-2
else if(choice==1019202){
# 4个拼接到一个
second=-second
forth=-forth
# 计算新指标AB:
patternA[seq(1,n_sumtemp,4),]=1
patternA[seq(2,n_sumtemp,4),]=2
patternA[seq(3,n_sumtemp,4),]=1
patternA[seq(4,n_sumtemp,4),]=2
patternB[seq(1,n_sumtemp,4),]=2
patternB[seq(2,n_sumtemp,4),]=1
patternB[seq(3,n_sumtemp,4),]=2
patternB[seq(4,n_sumtemp,4),]=1
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
}
# 1019-3~1019-13在负正或正负时follow,与1019-1相反
else if(!(choice %in% c(1019,10191,10192,1019201,1019202))){
# 4个拼接到一个
sumtemp[seq(1,n_sumtemp,4),]=first
sumtemp[seq(2,n_sumtemp,4),]=second
sumtemp[seq(3,n_sumtemp,4),]=third
sumtemp[seq(4,n_sumtemp,4),]=forth
sumtemp[2,]=-sumtemp[2,]
patternA[1,]=1;patternA[2,]=2
patternB[1,]=2;patternB[2,]=1
for (i in seq(3,nrow(sumtemp)-1,2)) {
# condition为follow的条件：follow指的使用与上一个formula一样的
if(choice==10193)condition=!(sumtemp[i-1,]>0&sumtemp[i-2,]<0) # 3与13相反
else if(choice==10194)condition=!(sumtemp[i-1,]<0&sumtemp[i-2,]>0) #4与12相反
else if(choice==10195)condition=sumtemp[i-2,]>0 # 5与10相反
else if(choice==10196)condition=sumtemp[i-1,]>0 # 6与9相反
else if(choice==10197)condition=sumtemp[i-1,]>0&sumtemp[i-2,]>0 # 7与8相反
else if(choice==10198)condition=!(sumtemp[i-1,]>0&sumtemp[i-2,]>0)
else if(choice==10199)condition=sumtemp[i-1,]<0
else if(choice==101910)condition=sumtemp[i-2,]<0
else if(choice==101911)condition=sumtemp[i-1,]*sumtemp[i-2,]<0
else if(choice==101912)condition=sumtemp[i-1,]<0&sumtemp[i-2,]>0
else if(choice==101913)condition=sumtemp[i-1,]>0&sumtemp[i-2,]<0
else if(choice==101914){
condition1=(sumtemp[i-2,]<0&patternA[i-2,]==1)
condition2=(sumtemp[i-1,]<0&patternA[i-1,]==1)
}
else if(choice==101915){
condition1=(sumtemp[i-2,]>0&patternA[i-2,]==1)
condition2=(sumtemp[i-1,]>0&patternA[i-1,]==1)
}
if(choice!=101914&choice!=101915){condition1=condition;condition2=condition}
sumtemp[i,]=ifelse(condition1,ifelse(patternA[i-2,]==1,sumtemp[i,],-sumtemp[i,]),ifelse(patternA[i-2,]==1,-sumtemp[i,],sumtemp[i,]))
patternA[i,]=ifelse(condition1,ifelse(patternA[i-2,]==1,1,2),ifelse(patternA[i-2,]==1,2,1))
patternB[i,]=ifelse(condition1,ifelse(patternA[i-2,]==1,2,1),ifelse(patternA[i-2,]==1,1,2))
sumtemp[i+1,]=ifelse(condition2,ifelse(patternA[i-1,]==1,sumtemp[i+1,],-sumtemp[i+1,]),ifelse(patternA[i-1,]==1,-sumtemp[i+1,],sumtemp[i+1,]))
patternA[i+1,]=ifelse(condition2,ifelse(patternA[i-1,]==1,1,2),ifelse(patternA[i-1,]==1,2,1))
patternB[i+1,]=ifelse(condition2,ifelse(patternA[i-1,]==1,2,1),ifelse(patternA[i-1,]==1,1,2))
}
}
}
# 3）每个数据集m计算多个评价指标：
{
# 计算连续负 “最大” 的手数
minus_result[m,]=detect_continue_minus(sumtemp)
# 计算新指标:等价于AIC、BIC等评价指标
# 1、正负比例
plus[m,]=apply(sumtemp, 2, function(x)sum(x>0))
minus[m,]=n_sumtemp-plus[m,]# 数据m下结果负的手数
# 2、新指标A&B
#新指标A，当某一手使用formula1时记为1，使用formula8时记为2，正负的话和这一手的final result的正负一致；
symbol=ifelse(sumtemp>0,1,-1)
new_indexA[m,]=colSums(patternA*symbol)
new_indexB[m,]=colSums(patternB*symbol)
# 3、新指标A1&B1 直接由final result和真实路径是多少就可以计算出来
# 所以当final result为正时，预测值与实际值相同，即直接使用实际路径的s或d就是预测值与前一手的s或d
# 当为负，说明预测错误，预测值与实际值相反，预测值与前一手的结果s或d应该与实际值与前一手的s或d相反
pred_s_or_d=ifelse(symbol>0,real_s_or_d,-real_s_or_d) #1为s
patternA1=ifelse(pred_s_or_d==1,2,1)
patternB1=ifelse(pred_s_or_d==1,1,2)
new_indexA1[m,]=colSums(patternA1*symbol)
new_indexB1[m,]=colSums(patternB1*symbol)
# 4、新指标C-1：正负由final result的正负决定，绝对值 为1记为1，其他为2
patternC1=ifelse(sumtemp==1|sumtemp==-1,1,2)
new_indexc1[m,]=colSums(patternC1*symbol)
# 5、新指标c-2:
#新指标C-2：相对C（现在为C-1），若final_result 是使用original formula得到的
#则C-2与C-2相同，若使用的是opposite formula，则“相反”——1记为2，其他记为1：
# c-2是在C-1基础上根据是否使用opposite formula进行变化,因为patternA记录是否使用opposite，1为origin，2为opposite
# patternC2为1的条件：sumtemp绝对值为1，且使用original即patternA=1，
# 或sumtemp绝对值为3，且使用opposite即patternA=2，刚好反过来
patternC2=ifelse((patternA==1&abs(sumtemp)==1)|(patternA==2&abs(sumtemp)==3),1,2)
new_indexc2[m,]=colSums(patternC2*symbol)
# 6、指标D：
# 第一、二手用1（初始化为1）。第三手根据第一首的final result ，当其为正则第三手为2，否则为1；
# 第四手根据第二手，若其为正则第四手为2，否则为1;以此类推，56根据34，78根据56，滚动下去
# 1还是2与横向前一手的正负相关，与“是否反一反”无关；正负还是与final result一样
patternD=rbind(matrix(rep(1,8*2),ncol = 8),ifelse(symbol>0,2,1)[-c(nrow(symbol),nrow(symbol)-1),])
new_indexD[m,]=colSums(patternD*symbol)
# 7、指标E：1、2手固定1；3，4手固定2，正负根据final result
patternE=matrix(rep(c(rep(c(1,1,2,2),n_sumtemp%/%4),c(1,1,2,2)[0:(n_sumtemp%%4)]),8),ncol = 8)
new_indexE[m,]=colSums(patternE*symbol)
}
}
colnames(minus_result)=c(paste0('formula',1:n_path))
# result存放满足连续负个数小于等于5的结果
result=matrix(nrow =max(minus_result) ,ncol = n_path)
for (i in 1:(max(minus_result))){
result[i,]=apply(minus_result,2,function(x)sum(x==i))
}
colnames(result)=c(paste0('formula',1:n_path))
# satisfy为某一个formula满足小于等于5的数据集个数：
satisfy=apply(result[1:5,], 2, sum)
return(list(minus_result,result,satisfy,plus,minus,
new_indexA,new_indexB,new_indexA1,new_indexB1,
new_indexc1,new_indexc2,new_indexD,new_indexE))
}
# 2.6 展示函数
present=function(result,index_c=T){
print(result[[2]])
cat('\n')
final_result=rbind(round(apply(result[[6]], 2, function(x)sum(x>=0))/760,3),round(apply(result[[8]], 2, function(x)sum(x>=0))/760,3))
final_result=rbind(final_result,round(apply(result[[7]], 2, function(x)sum(x>=0))/760,3))
final_result=rbind(final_result,round(apply(result[[9]], 2, function(x)sum(x>=0))/760,3))
final_result=rbind(final_result,round(colSums(result[[4]])/colSums(result[[5]]),3))
row.names(final_result)=c('A_ratio','A1_ratio','B_ratio','B1_ratio','plus/minus')
colnames(final_result)=c(paste0('formula',1:8))
final_result1=rbind(result[[3]],apply(result[[6]], 2, sum))
final_result1=rbind(final_result1,apply(result[[8]], 2, sum))
final_result1=rbind(final_result1,apply(result[[7]], 2, sum))
final_result1=rbind(final_result1,apply(result[[9]], 2, sum))
final_result1=rbind(final_result1,colSums(result[[4]]))
final_result1=rbind(final_result1,colSums(result[[5]]))
final_result1=rbind(final_result1,colSums(result[[10]]))
final_result1=rbind(final_result1,colSums(result[[11]]))
final_result1=rbind(final_result1,colSums(result[[12]]))
final_result1=rbind(final_result1,colSums(result[[13]]))
row.names(final_result1)=c('quantity  ','A_sum','A1_sum','B_sum','B1_sum','plus','minus','C1_sum','C2_sum','D_sum','E_sum')
first5_A=apply(result[[6]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_A=apply(result[[6]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_B=apply(result[[7]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_B=apply(result[[7]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_A1=apply(result[[8]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_A1=apply(result[[8]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_B1=apply(result[[9]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_B1=apply(result[[9]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_c1=apply(result[[10]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_c1=apply(result[[10]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_c2=apply(result[[11]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_c2=apply(result[[11]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_d=apply(result[[12]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_d=apply(result[[12]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
first5_e=apply(result[[13]], 2, function(x)str_c(sort(x,decreasing = T)[1:5],collapse = ' '))
last5_e=apply(result[[13]], 2, function(x)str_c(sort(x,decreasing = F)[1:5],collapse = ' '))
A=str_c(first5_A,last5_A,sep  = ';')
B=str_c(first5_B,last5_B,sep  = ';')
A1=str_c(first5_A1,last5_A1,sep  = ';')
B1=str_c(first5_B1,last5_B1,sep  = ';')
c1=str_c(first5_c1,last5_c1,sep  = ';')
c2=str_c(first5_c2,last5_c2,sep  = ';')
d=str_c(first5_d,last5_d,sep  = ';')
e=str_c(first5_e,last5_e,sep  = ';')
ss=data.frame(A=A,A1=A1,B=B,B1=B1,C1=c1,C2=c2,D=d,E=e)
row.names(ss)=c(paste0('formula',1:8))
colnames(ss)=c('first&last5 of index A','first&last5 of index A1','first&last5 of index B','first&last5 of index B1',
'first&last5 of index C1','first&last5 of index C2','first&last5 of index D','first&last5 of index E')
if(index_c){
print(ss)
cat('\n')
print(final_result)
print(final_result1)
}
else{
print(ss[c('first&last5 of index A','first&last5 of index A1','first&last5 of index B','first&last5 of index B1',
'first&last5 of index D','first&last5 of index E')])
cat('\n')
print(final_result)
print(final_result1[c('quantity  ','A_sum','A1_sum','B_sum','B1_sum','plus','minus','D_sum','E_sum'),])
}
}
plan1211_1_YAY579=run(data = all_data,path = path_BP_YAY579,inverse = F,choice=12111,rolling=F,reflection=F,cross = F)
present(plan1211_1_YAY579,index_c = F)
plan1211_2_YAY679=run(data = all_data,path = path_BP_YAY579,inverse = F,choice=12112,rolling=F,reflection=F,cross = F)
present(plan1211_2_YAY579,index_c = F)
plan1211_3_YAY579=run(data = all_data,path = path_BP_YAY579,inverse = F,choice=12113,rolling=F,reflection=F,cross = F)
present(plan1211_3_YAY579,index_c = F)
plan1211_4_YAY579=run(data = all_data,path = path_BP_YAY579,inverse = F,choice=12114,rolling=F,reflection=F,cross = F)
present(plan1211_4_YAY579,index_c = F)
present(plan1211_2_YAY679,index_c = F)
present(plan1211_4_YAY579,index_c = F)
present(plan1211_1_YAY579,index_c = F)
present(plan1211_1_YAY579,index_c = F)
present(plan1211_2_YAY679,index_c = F)
present(plan1211_3_YAY579,index_c = F)
present(plan1211_4_YAY579,index_c = F)
